SELECT t.* from json_table('{"a":{"b":"c"}}'::jsonb, '$.a' columns(b text format json path '$.b'))t; SELECT t.* from json_table('{"a":{"b":"c"}}'::jsonb, '$.a' columns(b text exists path '$.b'))t; SELECT * FROM (VALUES ('1'), ('"err"')) vals(js) LEFT OUTER JOIN JSON_TABLE(vals.js::jsonb, '$' COLUMNS (a int PATH '$' NULL ON ERROR) ERROR ON ERROR) jt ON true; CREATE TEMP TABLE jsonb_table_test (js jsonb); INSERT INTO jsonb_table_test VALUES ( '[ {"a": 1, "b": [], "c": []}, {"a": 2, "b": [1, 2, 3], "c": [10, null, 20]} ]' ); åºç¡æ°æ®1-ä¾å­1ï¼ select jt.* from jsonb_table_test jtt, json_table ( jtt.js,'strict $[*]' as p columns ( n for ordinality, a int path 'lax $.a' default -1 on empty, nested path 'strict $.b[*]' as pb columns ( b int path '$' ), nested path 'strict $.c[*]' as pc columns ( c int path '$' ) ) plan (p outer (pb union pc)) ) jt; CREATE TEMP TABLE jsonb_table_test (js jsonb); INSERT INTO jsonb_table_test VALUES ( '[ {"a": 1, "b": [], "c": []}, {"a": 2, "b": [1, 2, 3], "c": [10, null, 20]}, {"a": 3, "b": [1, 2], "c": []}, {"x": "4", "b": [1, 2], "c": 123} ]' ); åºç¡æ°æ®2-ä¾å­1: select jt.* from jsonb_table_test jtt, json_table ( jtt.js,'strict $[*]' as p columns ( n for ordinality, a int path 'lax $.a' default -1 on empty, nested path 'strict $.b[*]' as pb columns ( b int path '$' ), nested path 'strict $.c[*]' as pc columns ( c int path '$' ) ) plan default (outer, union) ) jt; CREATE TABLE my_films ( js jsonb ); INSERT INTO my_films VALUES ( '{ "favorites": [ { "kind": "comedy", "films": [ { "title": "Bananas", "director": "Woody Allen" }, { "title": "The Dinner Game", "director": "Francis Veber" } ] }, { "kind": "horror", "films": [ { "title": "Psycho", "director": "Alfred Hitchcock" } ] }, { "kind": "thriller", "films": [ { "title": "Vertigo", "director": "Alfred Hitchcock" } ] }, { "kind": "drama", "films": [ { "title": "Yojimbo", "director": "Akira Kurosawa" } ] } ] }'); åºç¡æ°æ®3-ä¾å­1ï¼ SELECT jt.* FROM my_films, JSON_TABLE ( js, '$.favorites[*]' COLUMNS ( id FOR ORDINALITY, kind text PATH '$.kind', NESTED PATH '$.films[*]' COLUMNS ( title text PATH '$.title', director text PATH '$.director'))) AS jt; SELECT director1 AS director, title1, kind1, title2, kind2 FROM my_films, JSON_TABLE ( js, '$.favorites' AS favs COLUMNS ( NESTED PATH '$[*]' AS films1 COLUMNS ( kind1 text PATH '$.kind', NESTED PATH '$.films[*]' AS film1 COLUMNS ( title1 text PATH '$.title', director1 text PATH '$.director') ), NESTED PATH '$[*]' AS films2 COLUMNS ( kind2 text PATH '$.kind', NESTED PATH '$.films[*]' AS film2 COLUMNS ( title2 text PATH '$.title', director2 text PATH '$.director' ) ) ) PLAN (favs OUTER ((films1 INNER film1) CROSS (films2 INNER film2))) ) AS jt WHERE kind1 > kind2 AND director1 = director2;